
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Kassy Glassy — 1v1 Slot Tournament (Demo)</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #0b0b10; color: #111; }
    .shell { max-width: 1080px; margin: 24px auto; padding: 16px; }
    .card { background: #fff; border: 1px solid #e5e7eb; border-radius: 16px; box-shadow: 0 4px 24px rgba(0,0,0,0.08); padding: 16px; }
    .row { display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media(min-width: 900px){ .row { grid-template-columns: 320px 1fr; } }
    .controls label { display:block; font-size:12px; color:#6b7280; margin-bottom:4px; }
    .controls input, .controls select, .controls button, .btn { width: 100%; padding: 10px 12px; border: 1px solid #e5e7eb; border-radius: 12px; font-size: 14px; }
    .controls input:focus, .controls select:focus { outline: none; border-color: #818cf8; box-shadow: 0 0 0 3px rgba(129,140,248,0.2); }
    .btn-primary { background:#111827; color:white; border-color:#111827; cursor:pointer; }
    .btn-primary:disabled { opacity: .6; cursor: not-allowed; }
    .pill { display:inline-flex; align-items:center; gap:8px; font-size:12px; padding:6px 10px; border-radius:999px; background:#f3f4f6; color:#111827; }
    .grid { display:grid; grid-template-columns: repeat(5, 1fr); gap: 6px; background:#f3f4f6; padding:10px; border-radius:16px; box-shadow: inset 0 2px 8px rgba(0,0,0,0.05); }
    .cell { height: 56px; display:flex; align-items:center; justify-content:center; background:white; border-radius:12px; font-weight:700; font-size:12px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
    .small { font-size:12px; color:#6b7280; }
    .badge-win { background:#ecfdf5; color:#065f46; border:1px solid #d1fae5; padding:4px 8px; border-radius:10px; font-size:12px; display:inline-block; }
    .badge-feature { background:#eef2ff; color:#3730a3; border:1px solid #e0e7ff; padding:4px 8px; border-radius:10px; font-size:12px; display:inline-block; }
    .splash { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: radial-gradient(80% 80% at 50% 50%, rgba(255,255,255,0.75), rgba(255,255,255,0.1)); pointer-events:none; }
    .splash.show { display:flex; animation: pop 800ms ease-out forwards; }
    @keyframes pop { 0% { transform: scale(0.96); opacity:0; } 30% { opacity:1; } 100% { transform: scale(1); opacity:0; } }
    .splash-card { background:white; border-radius:20px; padding:24px 28px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); border:1px solid #e5e7eb; }
    .title { font-size: 22px; font-weight: 800; letter-spacing: .2px; }
    .subtitle { font-size: 12px; color: #6b7280; }
    .topbar { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
    .headline { font-size:18px; font-weight:700; }
    .chip { padding:6px 10px; background:#eef2ff; color:#3730a3; border:1px solid #e0e7ff; border-radius:999px; font-size:12px; }
    .muted { color:#6b7280; }
    .divider { height: 1px; background: #e5e7eb; margin: 8px 0 12px; }
    .note { font-size: 12px; color: #6b7280; }
    .stick { position: sticky; top: 12px; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card" style="background:linear-gradient(180deg,#f5f3ff, #ffffff); border-color:#e9d5ff;">
      <div class="topbar">
        <div>
          <div class="title">Kassy Glassy — 1v1 Slot Tournament (Demo)</div>
          <div class="subtitle">Seeded & fair • 50 spins each • No real money • Original math</div>
        </div>
        <div class="pill">v1.2 • Crystal Free Spins + Stacked Wilds</div>
      </div>
      <div class="divider"></div>
      <div class="row">
        <div class="controls card stick">
          <div style="margin-bottom:12px;">
            <label>Your name</label>
            <input id="name" placeholder="Player" />
          </div>
          <div style="margin-bottom:12px;">
            <label>Game</label>
            <select id="game">
              <option value="kassy-glassy">Kassy Glassy</option>
              <option value="thunder-links">Thunder Links</option>
            </select>
          </div>
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:12px;">
            <div>
              <label>Bet (total)</label>
              <input id="bet" type="number" min="1" step="1" value="10"/>
            </div>
            <div>
              <label>Seed</label>
              <input id="seed" type="number" />
            </div>
          </div>
          <button id="reset" class="btn-primary">Start / Reset Match</button>
          <div style="margin-top:10px;">
            <button id="copyLink" class="btn">Copy Match Link</button>
          </div>
          <div style="margin-top:10px; background:#f3f4f6; border-radius:12px; padding:10px;">
            <div>Spins left: <b id="spinsLeft">50</b></div>
            <div>Credit: <b id="credit">1,000</b></div>
            <div id="fsBanner" class="chip" style="display:none; margin-top:8px;">CRYSTAL FREE SPINS ACTIVE</div>
            <div id="over" style="color:#047857; margin-top:6px; display:none;">Match over — share your seed & score!</div>
          </div>
          <div style="margin-top:10px;" class="note">
            Local leaderboard (per-seed): <b id="bestScore">—</b>
          </div>
        </div>

        <div class="card" style="border-color:#e5e7eb;">
          <div class="topbar">
            <div class="headline" id="gameName">Kassy Glassy</div>
            <button id="spin" class="btn-primary">Spin</button>
          </div>
          <div id="gridMount" class="grid" style="margin-bottom:10px;"></div>
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
            <div class="small" id="betInfo">Bet: 10 • Lines: 10</div>
            <div style="font-weight:700;">Win: <span id="winLast">0</span></div>
          </div>
          <div id="wins"></div>
          <div class="note" style="margin-top:10px;">Demo math aims for arcade fun, not certified RTP. For real-money or brand usage, obtain proper licensing and certified math.</div>
        </div>
      </div>

      <div class="card" style="margin-top:16px;">
        <div style="font-weight:700; margin-bottom:8px;">Recent Spins</div>
        <div id="history" style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;"></div>
      </div>
    </div>
  </div>

  <div id="splash" class="splash">
    <div class="splash-card">
      <div style="font-weight:800; font-size:18px; margin-bottom:6px;">BIG WIN!</div>
      <div class="muted" id="splashDetail">—</div>
    </div>
  </div>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // RNG
    function mulberry32(a) {
      return function () {
        let t = (a += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    const PAYLINES = [
      [0,0,0,0,0],[1,1,1,1,1],[2,2,2,2,2],
      [0,1,2,1,0],[2,1,0,1,2],
      [0,0,1,0,0],[1,2,2,2,1],
      [2,2,1,2,2],[1,0,0,0,1],[0,1,1,1,0],
    ];

    // ---------- Kassy Glassy with Stacked Wilds + Crystal Free Spins ----------
    const KassyGlassy = {
      id: "kassy-glassy",
      title: "Kassy Glassy",
      rows: 3,
      reelsCount: 5,
      lines: PAYLINES,
      totalLines: PAYLINES.length,
      betPerLine: 1,
      wild: "SPACE_J",
      scat: "CRYSTAL",
      // Base strips (include extra SPACE_J entries to simulate stacking)
      reels: [
        ["GLASS","A","Q","SPACE_J","BONG","K","J","T","TORCH","9","Q","K","B100","A","J","Q","K","A","9","SPACE_J","SPACE_J"],
        ["Q","BONG","A","K","J","T","SPACE_J","TORCH","Q","9","B50","K","A","J","Q","GLASS","K","A","9","SPACE_J"],
        ["A","K","Q","J","TORCH","SPACE_J","T","9","A","K","Q","B50","J","GLASS","K","Q","A","9","T","SPACE_J"],
        ["J","Q","K","A","B100","J","Q","K","SPACE_J","A","GLASS","Q","K","A","9","T","BONG","Q","K","SPACE_J"],
        ["T","9","A","K","Q","J","GLASS","A","K","Q","SPACE_J","BONG","A","K","Q","J","9","TORCH","B50","SPACE_J"],
      ],
      paytable: {
        GLASS: {3: 20, 4: 80, 5: 420},
        BONG:  {3: 16, 4: 60, 5: 320},
        TORCH: {3: 12, 4: 40, 5: 200},
        B100:  {3: 10, 4: 30, 5: 160},
        B50:   {3: 8,  4: 24, 5: 120},
        A: {3: 8, 4: 20, 5: 60},
        K: {3: 7, 4: 18, 5: 50},
        Q: {3: 6, 4: 16, 5: 40},
        J: {3: 5, 4: 14, 5: 30},
        T: {3: 4, 4: 12, 5: 24},
        "9": {3: 3, 4: 10, 5: 20},
      },
      scatterPays: {3: 20, 4: 80, 5: 300},
      // During free spins, two low symbols are upgraded to GLASS-equivalent pays
      evaluateSpin(grid, rand, state) {
        const lines = this.lines;
        let win = 0;
        let lineWins = [];

        // Apply stacked wilds chance: randomly expand single SPACE_Js into vertical stacks in a reel (during spin only)
        const stackedGrid = grid.map(r => r.slice());
        for (let reel = 0; reel < this.reelsCount; reel++) {
          if (Math.random() < 0.18) { // 18% chance to force a 2- or 3-high stack
            const startRow = Math.floor(Math.random() * this.rows);
            const height = Math.random() < 0.5 ? 2 : 3;
            for (let h = 0; h < height; h++) {
              const rr = (startRow + h) % this.rows;
              stackedGrid[rr][reel] = this.wild;
            }
          }
        }

        const upgradeSet = state.freeSpinsActive ? state.upgradedLows : new Set();

        // Line pays (with wilds & upgrades)
        for (let li = 0; li < lines.length; li++) {
          const pattern = lines[li];
          const combo = pattern.map((row, reel) => stackedGrid[row][reel]);
          const candidates = combo.filter((s) => s !== this.wild && s !== this.scat);
          if (candidates.length === 0) continue;
          let sym = candidates[0];
          // Upgrade low symbols to GLASS-equivalent during FS
          const symForPay = (upgradeSet.has(sym) ? "GLASS" : sym);
          const pt = this.paytable[symForPay];
          if (!pt) continue;
          let count = 0;
          for (let i = 0; i < combo.length; i++) {
            const s = combo[i];
            const sPay = (upgradeSet.has(s) ? "GLASS" : s);
            if (s === this.wild || sPay === symForPay) count++;
            else break;
          }
          if (count >= 3) {
            const pay = pt[count] || 0;
            if (pay > 0) {
              win += pay;
              lineWins.push({ line: li + 1, symbol: symForPay, count, pay });
            }
          }
        }

        // Scatter pays anywhere
        const flat = stackedGrid.flat();
        const scatCount = flat.filter((s) => s === this.scat).length;
        if (scatCount >= 3) {
          const sPay = this.scatterPays[scatCount] || 0;
          if (sPay > 0) {
            win += sPay;
            lineWins.push({ line: "SCAT", symbol: this.scat, count: scatCount, pay: sPay });
          }
        }

        // Trigger Crystal Free Spins (10) on 3+ scatters if not already active
        let feature = null;
        if (!state.freeSpinsActive && scatCount >= 3) {
          feature = { type: "CrystalFreeSpins", spins: 10 };
        }

        return { win, lineWins, feature, grid: stackedGrid };
      },
      // pick two lows to upgrade
      pickUpgrades(rand) {
        const lows = ["A","K","Q","J","T","9"];
        const pool = lows.slice();
        const up1 = pool.splice(Math.floor(rand()*pool.length), 1)[0];
        const up2 = pool.splice(Math.floor(rand()*pool.length), 1)[0];
        return new Set([up1, up2]);
      }
    };

    // ---------- Thunder Links (unchanged base + link feature) ----------
    const ThunderLinks = {
      id: "thunder-links",
      title: "Thunder Links",
      rows: 3, reelsCount: 5, lines: PAYLINES, totalLines: PAYLINES.length, betPerLine: 1,
      wild: "WILD", coin: "COIN",
      baseReels: [
        ["H1","A","Q","WILD","COIN","K","J","T","H3","9","Q","K","H4","A","J","Q","K","A","9"],
        ["Q","H2","A","K","J","T","WILD","H3","COIN","9","H4","K","A","J","Q","H1","K","A","9"],
        ["A","K","Q","J","H3","WILD","COIN","9","A","K","Q","H4","J","H1","K","Q","A","9","T"],
        ["J","Q","K","A","H4","J","Q","K","WILD","A","H1","Q","K","A","COIN","9","T","H2","Q","K"],
        ["T","9","A","K","Q","J","H1","A","K","Q","WILD","H2","A","K","Q","J","9","H3","H4","COIN"],
      ],
      paytable: {
        H1:{3:20,4:70,5:300}, H2:{3:16,4:60,5:240}, H3:{3:12,4:40,5:160}, H4:{3:10,4:30,5:120},
        A:{3:8,4:20,5:50}, K:{3:7,4:18,5:40}, Q:{3:6,4:16,5:36}, J:{3:5,4:14,5:28}, T:{3:4,4:12,5:24}, "9":{3:3,4:10,5:20},
      },
      evaluateSpin(grid, rand) {
        let win = 0; let lineWins = [];
        for (let li = 0; li < this.lines.length; li++) {
          const pattern = this.lines[li];
          const combo = pattern.map((row, reel) => grid[row][reel]);
          const candidates = combo.filter((s) => s !== this.wild && s !== this.coin);
          if (candidates.length === 0) continue;
          const sym = candidates[0]; const pt = this.paytable[sym]; if (!pt) continue;
          let count = 0;
          for (let i=0;i<combo.length;i++){ const s=combo[i]; if (s===sym || s===this.wild) count++; else break; }
          if (count>=3){ const pay = pt[count]||0; if (pay>0){ win+=pay; lineWins.push({ line: li+1, symbol: sym, count, pay }); } }
        }
        const flat = grid.flat(); const coinCount = flat.filter(s=>s===this.coin).length;
        let feature = null;
        if (coinCount >= 6) { feature = this.playLinkFeature(coinCount, rand); win += feature.total; }
        return { win, lineWins, feature };
      },
      playLinkFeature(startCoins, rand) {
        let coins = []; for (let i=0;i<startCoins;i++) coins.push(1 + Math.floor(rand()*20));
        let respins = 3;
        while (respins>0){ const hit = rand()<0.45; if (hit){ coins.push(1 + Math.floor(rand()*20)); respins=3; } else { respins--; } }
        const total = coins.reduce((a,b)=>a+b,0);
        return { type: "ThunderLink", coins, total };
      }
    };

    function spinReels(game, rand) {
      const { reelsCount, rows } = game;
      const grid = Array.from({ length: rows }, () => Array(reelsCount).fill(null));
      const reels = (game.reels || game.baseReels);
      for (let r=0; r<reelsCount; r++) {
        const strip = reels[r];
        const start = Math.floor(rand() * strip.length);
        for (let row=0; row<rows; row++) grid[row][r] = strip[(start+row) % strip.length];
      }
      return grid;
    }
    function formatCredits(x){ return Number(x).toLocaleString(); }

    // Minimal React wrapper for controlled state + DOM bridges (for speed)
    function useQuery() {
      const [q, setQ] = React.useState(() => new URLSearchParams(window.location.search));
      React.useEffect(()=>{
        const onPop = ()=> setQ(new URLSearchParams(window.location.search));
        window.addEventListener("popstate", onPop);
        return ()=> window.removeEventListener("popstate", onPop);
      },[]);
      return q;
    }

    function App(){
      const query = useQuery();
      const games = React.useMemo(()=>({ "kassy-glassy": KassyGlassy, "thunder-links": ThunderLinks }),[]);
      const [gameId, setGameId] = React.useState(query.get("game") || "kassy-glassy");
      const [seed, setSeed] = React.useState(Number(query.get("seed")) || Math.floor(Math.random()*1e9));
      const [playerName, setPlayerName] = React.useState(localStorage.getItem("playerName") || "Player");
      const [spinsLeft, setSpinsLeft] = React.useState(50);
      const [credit, setCredit] = React.useState(1000);
      const [bet, setBet] = React.useState(10);
      const [lastGrid, setLastGrid] = React.useState(null);
      const [lastResult, setLastResult] = React.useState(null);
      const [history, setHistory] = React.useState([]);
      const [matchOver, setMatchOver] = React.useState(false);
      const [freeSpinsActive, setFreeSpinsActive] = React.useState(false);
      const [freeSpinsLeft, setFreeSpinsLeft] = React.useState(0);
      const [upgradedLows, setUpgradedLows] = React.useState(new Set());
      const rngRef = React.useRef(mulberry32(seed));
      const game = games[gameId];

      React.useEffect(()=> localStorage.setItem("playerName", playerName), [playerName]);
      React.useEffect(()=>{
        const u = new URL(window.location.href);
        u.searchParams.set("seed", String(seed)); u.searchParams.set("game", String(gameId));
        window.history.replaceState({}, "", u.toString());
      },[seed, gameId]);

      React.useEffect(()=>{
        if (spinsLeft === 0 && !matchOver && !freeSpinsActive) setMatchOver(true);
      },[spinsLeft, matchOver, freeSpinsActive]);

      React.useEffect(()=>{
        // hydrate inputs in left panel
        document.getElementById("name").value = playerName;
        document.getElementById("game").value = gameId;
        document.getElementById("bet").value = bet;
        document.getElementById("seed").value = seed;
        document.getElementById("spinsLeft").textContent = String(spinsLeft);
        document.getElementById("credit").textContent = formatCredits(credit);
        document.getElementById("gameName").textContent = game.title;
        document.getElementById("betInfo").textContent = `Bet: ${bet} • Lines: ${game.totalLines}`;
        document.getElementById("fsBanner").style.display = freeSpinsActive ? "inline-flex" : "none";
        document.getElementById("over").style.display = matchOver ? "block" : "none";
        // leaderboard (local, per seed + game)
        const key = `bestScore:${gameId}:${seed}`;
        const best = Number(localStorage.getItem(key) || "NaN");
        document.getElementById("bestScore").textContent = isNaN(best) ? "—" : formatCredits(best);
      },[playerName, gameId, bet, seed, spinsLeft, credit, matchOver, freeSpinsActive]);

      function resetMatch(){
        setSpinsLeft(50); setCredit(1000);
        setLastGrid(null); setLastResult(null); setHistory([]);
        setMatchOver(false); setFreeSpinsActive(false); setFreeSpinsLeft(0);
        setUpgradedLows(new Set());
        rngRef.current = mulberry32(seed);
      }

      function showSplash(text){
        const el = document.getElementById("splash");
        const detail = document.getElementById("splashDetail");
        detail.textContent = text;
        el.classList.add("show");
        setTimeout(()=> el.classList.remove("show"), 900);
      }

      function pushHistory(grid, result){
        setHistory(h => [{ grid, result, bet }, ...h].slice(0, 10));
      }

      function updateBest(){
        const key = `bestScore:${gameId}:${seed}`;
        const prev = Number(localStorage.getItem(key) || "NaN");
        if (isNaN(prev) || credit > prev) {
          localStorage.setItem(key, String(credit));
          document.getElementById("bestScore").textContent = formatCredits(credit);
        }
      }

      function renderGrid(targetId, grid){
        const mount = document.getElementById(targetId);
        mount.innerHTML = "";
        grid.forEach(row=>{
          // each row is implicit via grid CSS; we append 5 cells per row
        });
        // Flatten for simplicity in DOM creation
        for (let r=0; r<grid.length; r++){
          for (let c=0; c<grid[0].length; c++){
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.textContent = grid[r][c];
            mount.appendChild(cell);
          }
        }
      }

      function spinOnce(){
        if (matchOver) return;
        const rand = rngRef.current;
        const state = { freeSpinsActive, upgradedLows };
        const grid = spinReels(game, rand);
        const result = game.evaluateSpin(grid, rand, state);

        // Feature handling
        let fsTriggered = false;
        if (result.feature && result.feature.type === "CrystalFreeSpins") {
          if (!freeSpinsActive) {
            const ups = game.pickUpgrades(rand);
            setUpgradedLows(ups);
            setFreeSpinsActive(true);
            setFreeSpinsLeft(result.feature.spins);
            fsTriggered = true;
          }
        }

        // credit delta
        const winCredits = Math.round(result.win * (bet / game.totalLines));
        const cost = freeSpinsActive ? 0 : bet;
        const newCredit = credit - cost + winCredits;
        setCredit(newCredit);
        document.getElementById("credit").textContent = formatCredits(newCredit);

        // update spins counters
        if (freeSpinsActive) {
          const left = freeSpinsLeft - 1;
          setFreeSpinsLeft(left);
          if (left <= 0) {
            setFreeSpinsActive(false);
          }
        } else {
          setSpinsLeft(s => s - 1);
        }

        // UI
        setLastGrid(result.grid || grid);
        setLastResult(result);
        renderGrid("gridMount", result.grid || grid);
        document.getElementById("winLast").textContent = String(winCredits);
        const wins = document.getElementById("wins");
        wins.innerHTML = "";
        (result.lineWins || []).forEach(lw => {
          const tag = document.createElement("div");
          tag.className = (lw.line === "SCAT") ? "badge-feature" : "badge-win";
          tag.textContent = (lw.line === "SCAT")
            ? `CRYSTAL x${lw.count} — ${lw.pay}x`
            : `Line ${lw.line}: ${lw.symbol} x${lw.count} — ${lw.pay}x`;
          wins.appendChild(tag);
        });

        if (winCredits >= bet * 5) showSplash(`You won ${formatCredits(winCredits)}!`);
        if (fsTriggered) showSplash("CRYSTAL FREE SPINS — 10 awarded!");
        pushHistory(result.grid || grid, result);
        updateBest();

        // End condition
        const spinsNow = freeSpinsActive ? spinsLeft : (spinsLeft - 1);
        if (spinsNow <= 0 && !freeSpinsActive) setMatchOver(true);
      }

      // wire DOM controls
      React.useEffect(()=>{
        const $ = (id)=>document.getElementById(id);
        $("name").onchange = (e)=> setPlayerName(e.target.value || "Player");
        $("game").onchange = (e)=> setGameId(e.target.value);
        $("bet").onchange = (e)=> setBet(Math.max(1, Number(e.target.value) || 1));
        $("seed").onchange = (e)=> setSeed(Number(e.target.value)||0);
        $("reset").onclick = resetMatch;
        $("spin").onclick = spinOnce;
        $("copyLink").onclick = ()=>{
          const u = new URL(window.location.href);
          u.searchParams.set("seed", String(seed));
          u.searchParams.set("game", String(gameId));
          navigator.clipboard.writeText(u.toString());
          alert("Match link copied — send this to your friend!");
        };
        // init seed
        if (!query.get("seed")) $("seed").value = seed;
      },[seed, gameId, query]);

      // initial empty grid render
      React.useEffect(()=>{
        const blank = Array.from({length: game.rows}, ()=> Array(game.reelsCount).fill("—"));
        renderGrid("gridMount", blank);
      },[]);

      return null;
    }

    ReactDOM.createRoot(document.body.appendChild(document.createElement("div"))).render(<App/>);
  </script>
</body>
</html>
